This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-15T06:33:33.232Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
drizzle/
  meta/
    _journal.json
    0000_snapshot.json
    0001_snapshot.json
    0002_snapshot.json
    0003_snapshot.json
    0004_snapshot.json
  0000_lean_juggernaut.sql
  0001_minor_master_chief.sql
  0002_flowery_rage.sql
  0003_little_terrax.sql
  0004_crazy_robin_chapel.sql
src/
  db/
    index.ts
    migrate-db.ts
    migrate.ts
    schema.ts
    seed.ts
  handlers/
    auth.handlers.ts
  middleware/
    auth.ts
    rte-limiter.ts
  routes/
    auth.ts
  services/
    auth.service.ts
  types/
    session.d.ts
  utils/
    email.ts
    errors.ts
    session.ts
    validate.ts
  index.ts
drizzle.config.ts
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: drizzle/meta/_journal.json
================
{
  "version": "5",
  "dialect": "pg",
  "entries": [
    {
      "idx": 0,
      "version": "5",
      "when": 1731464909415,
      "tag": "0000_lean_juggernaut",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "5",
      "when": 1731465148687,
      "tag": "0001_minor_master_chief",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "5",
      "when": 1731465489193,
      "tag": "0002_flowery_rage",
      "breakpoints": true
    },
    {
      "idx": 3,
      "version": "5",
      "when": 1731648577382,
      "tag": "0003_little_terrax",
      "breakpoints": true
    },
    {
      "idx": 4,
      "version": "5",
      "when": 1731649964978,
      "tag": "0004_crazy_robin_chapel",
      "breakpoints": true
    }
  ]
}

================
File: drizzle/meta/0000_snapshot.json
================
{
  "id": "33355e11-d1b0-46d0-88ef-720719c3277e",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "5",
  "dialect": "pg",
  "tables": {
    "users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: drizzle/meta/0001_snapshot.json
================
{
  "id": "1b82a5c9-0225-4704-ad07-8791aaf36187",
  "prevId": "33355e11-d1b0-46d0-88ef-720719c3277e",
  "version": "5",
  "dialect": "pg",
  "tables": {
    "users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: drizzle/meta/0002_snapshot.json
================
{
  "id": "aafb5546-b3be-4387-8d59-49f299fe716c",
  "prevId": "1b82a5c9-0225-4704-ad07-8791aaf36187",
  "version": "5",
  "dialect": "pg",
  "tables": {
    "session": {
      "name": "session",
      "schema": "",
      "columns": {
        "sid": {
          "name": "sid",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "sess": {
          "name": "sess",
          "type": "json",
          "primaryKey": false,
          "notNull": true
        },
        "expire": {
          "name": "expire",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: drizzle/meta/0003_snapshot.json
================
{
  "id": "26811f3b-a422-4e4b-aa25-36bcce30ea74",
  "prevId": "aafb5546-b3be-4387-8d59-49f299fe716c",
  "version": "5",
  "dialect": "pg",
  "tables": {
    "login_attempts": {
      "name": "login_attempts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "success": {
          "name": "success",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "password_resets": {
      "name": "password_resets",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "used": {
          "name": "used",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "password_resets_user_id_users_id_fk": {
          "name": "password_resets_user_id_users_id_fk",
          "tableFrom": "password_resets",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "session": {
      "name": "session",
      "schema": "",
      "columns": {
        "sid": {
          "name": "sid",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "sess": {
          "name": "sess",
          "type": "json",
          "primaryKey": false,
          "notNull": true
        },
        "expire": {
          "name": "expire",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_agent": {
          "name": "user_agent",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        },
        "last_activity": {
          "name": "last_activity",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "session_user_id_users_id_fk": {
          "name": "session_user_id_users_id_fk",
          "tableFrom": "session",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: drizzle/meta/0004_snapshot.json
================
{
  "id": "e1373df8-73c7-49e3-b801-792d81573bf4",
  "prevId": "26811f3b-a422-4e4b-aa25-36bcce30ea74",
  "version": "5",
  "dialect": "pg",
  "tables": {
    "login_attempts": {
      "name": "login_attempts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "success": {
          "name": "success",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "password_resets": {
      "name": "password_resets",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "token": {
          "name": "token",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "used": {
          "name": "used",
          "type": "boolean",
          "primaryKey": false,
          "notNull": true,
          "default": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "password_resets_user_id_users_id_fk": {
          "name": "password_resets_user_id_users_id_fk",
          "tableFrom": "password_resets",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "session": {
      "name": "session",
      "schema": "",
      "columns": {
        "sid": {
          "name": "sid",
          "type": "varchar",
          "primaryKey": true,
          "notNull": true
        },
        "sess": {
          "name": "sess",
          "type": "json",
          "primaryKey": false,
          "notNull": true
        },
        "expire": {
          "name": "expire",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "user_agent": {
          "name": "user_agent",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        },
        "last_activity": {
          "name": "last_activity",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "session_user_id_users_id_fk": {
          "name": "session_user_id_users_id_fk",
          "tableFrom": "session",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: drizzle/0000_lean_juggernaut.sql
================
CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"first_name" varchar(50) NOT NULL,
	"last_name" varchar(50) NOT NULL,
	"email" varchar(255) NOT NULL,
	"created_at" timestamp DEFAULT now(),
	CONSTRAINT "users_email_unique" UNIQUE("email")
);

================
File: drizzle/0001_minor_master_chief.sql
================
ALTER TABLE "users" ADD COLUMN "password" text NOT NULL;

================
File: drizzle/0002_flowery_rage.sql
================
CREATE TABLE IF NOT EXISTS "session" (
	"sid" varchar PRIMARY KEY NOT NULL,
	"sess" json NOT NULL,
	"expire" timestamp NOT NULL
);

================
File: drizzle/0003_little_terrax.sql
================
CREATE TABLE IF NOT EXISTS "login_attempts" (
	"id" serial PRIMARY KEY NOT NULL,
	"email" varchar(255) NOT NULL,
	"success" boolean NOT NULL,
	"ip_address" varchar(45) NOT NULL,
	"timestamp" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "password_resets" (
	"id" serial PRIMARY KEY NOT NULL,
	"user_id" integer NOT NULL,
	"token" text NOT NULL,
	"expires_at" timestamp NOT NULL,
	"used" boolean DEFAULT false NOT NULL,
	"created_at" timestamp DEFAULT now(),
	"updated_at" timestamp DEFAULT now()
);
--> statement-breakpoint
ALTER TABLE "session" ADD COLUMN "user_id" integer NOT NULL;--> statement-breakpoint
ALTER TABLE "session" ADD COLUMN "user_agent" text;--> statement-breakpoint
ALTER TABLE "session" ADD COLUMN "ip_address" varchar(45);--> statement-breakpoint
ALTER TABLE "session" ADD COLUMN "last_activity" timestamp DEFAULT now();--> statement-breakpoint
ALTER TABLE "session" ADD COLUMN "created_at" timestamp DEFAULT now();--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "session" ADD CONSTRAINT "session_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "password_resets" ADD CONSTRAINT "password_resets_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;

================
File: drizzle/0004_crazy_robin_chapel.sql
================
ALTER TABLE "session" ALTER COLUMN "user_id" DROP NOT NULL;

================
File: src/db/index.ts
================
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as dotenv from "dotenv";

dotenv.config();

const client = postgres(process.env.DATABASE_URL!);
export const db = drizzle(client);

================
File: src/db/migrate-db.ts
================
import { drizzle } from "drizzle-orm/postgres-js";
import { migrate } from "drizzle-orm/postgres-js/migrator";
import postgres from "postgres";
import * as dotenv from "dotenv";

dotenv.config();

async function runMigrations() {
  const migrationClient = postgres(process.env.DATABASE_URL!, { max: 1 });
  const db = drizzle(migrationClient);

  console.log("Starting migrations...");

  try {
    await migrate(db, {
      migrationsFolder: "./drizzle",
    });
    console.log("Migrations completed successfully");
  } catch (error) {
    console.error("Migration failed:", error);
    throw error;
  } finally {
    await migrationClient.end();
  }
}

runMigrations().catch((err) => {
  console.error("Migration failed:", err);
  process.exit(1);
});

================
File: src/db/migrate.ts
================
import { drizzle } from "drizzle-orm/postgres-js";
import { migrate } from "drizzle-orm/postgres-js/migrator";
import { sql } from "drizzle-orm";
import postgres from "postgres";
import * as dotenv from "dotenv";

dotenv.config();

const migrationClient = postgres(process.env.DATABASE_URL!, { max: 1 });
const db = drizzle(migrationClient);

async function main() {
  try {
    console.log("Migration started...");

    // Create or modify users table
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR(50) NOT NULL,
        last_name VARCHAR(50) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        password TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create session table with proper indexes
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS session (
        sid VARCHAR PRIMARY KEY,
        sess JSON NOT NULL,
        expire TIMESTAMP(6) NOT NULL
      )
    `);

    await db.execute(sql`
      CREATE INDEX IF NOT EXISTS IDX_session_expire ON session (expire)
    `);

    console.log("Migration completed successfully");
  } catch (error) {
    console.error("Migration failed:", error);
    throw error;
  } finally {
    await migrationClient.end();
  }
}

main().catch((err) => {
  console.error("Migration failed:", err);
  process.exit(1);
});

================
File: src/db/schema.ts
================
import {
  pgTable,
  serial,
  varchar,
  timestamp,
  text,
  json,
  boolean,
  integer,
} from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  firstName: varchar("first_name", { length: 50 }).notNull(),
  lastName: varchar("last_name", { length: 50 }).notNull(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  password: text("password").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const sessions = pgTable("session", {
  sid: varchar("sid").primaryKey(),
  sess: json("sess").notNull(),
  expire: timestamp("expire").notNull(),
  userId: integer("user_id").references(() => users.id),
  userAgent: text("user_agent"),
  ipAddress: varchar("ip_address", { length: 45 }),
  lastActivity: timestamp("last_activity").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const passwordResets = pgTable("password_resets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id")
    .notNull()
    .references(() => users.id),
  token: text("token").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  used: boolean("used").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const loginAttempts = pgTable("login_attempts", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 255 }).notNull(),
  success: boolean("success").notNull(),
  ipAddress: varchar("ip_address", { length: 45 }).notNull(),
  timestamp: timestamp("timestamp").notNull(),
});

================
File: src/db/seed.ts
================
// src/db/seed.ts
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import bcrypt from "bcryptjs";
import * as dotenv from "dotenv";
import { users } from "./schema.js";

dotenv.config();

const client = postgres(process.env.DATABASE_URL!);
const db = drizzle(client);

interface UserSeed {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

async function seed() {
  try {
    console.log("Starting seed process...");

    // Clear existing data
    await db.delete(users);
    console.log("Cleared existing users");

    // Sample users with realistic data
    const sampleUsers: UserSeed[] = [
      {
        firstName: "John",
        lastName: "Doe",
        email: "john.doe@example.com",
        password: "Password123!",
      },
      {
        firstName: "Jane",
        lastName: "Smith",
        email: "jane.smith@example.com",
        password: "Password123!",
      },
      {
        firstName: "Alice",
        lastName: "Johnson",
        email: "alice.j@example.com",
        password: "Password123!",
      },
      {
        firstName: "Bob",
        lastName: "Wilson",
        email: "bob.w@example.com",
        password: "Password123!",
      },
      {
        firstName: "Carol",
        lastName: "Brown",
        email: "carol.b@example.com",
        password: "Password123!",
      },
      {
        firstName: "David",
        lastName: "Miller",
        email: "david.m@example.com",
        password: "Password123!",
      },
      {
        firstName: "Emma",
        lastName: "Davis",
        email: "emma.d@example.com",
        password: "Password123!",
      },
      {
        firstName: "Frank",
        lastName: "Garcia",
        email: "frank.g@example.com",
        password: "Password123!",
      },
      {
        firstName: "Grace",
        lastName: "Martinez",
        email: "grace.m@example.com",
        password: "Password123!",
      },
      {
        firstName: "Henry",
        lastName: "Anderson",
        email: "henry.a@example.com",
        password: "Password123!",
      },
    ];

    // Hash passwords and insert users
    const usersWithHashedPasswords = await Promise.all(
      sampleUsers.map(async (user) => ({
        ...user,
        password: await bcrypt.hash(user.password, 10),
      })),
    );

    // Insert users in batches
    const insertedUsers = await db
      .insert(users)
      .values(usersWithHashedPasswords)
      .returning({
        id: users.id,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
      });

    console.log("Successfully seeded users:");
    console.table(
      insertedUsers.map((user) => ({
        ...user,
        password: "Password123!", // Show the plain password in logs for testing
      })),
    );

    console.log("\nSeed completed successfully!");
    console.log(
      "\nYou can log in with any email using the password: Password123!",
    );
  } catch (error) {
    console.error("Seed failed:", error);
    throw error;
  } finally {
    await client.end();
  }
}

seed().catch((err) => {
  console.error("Seed process failed:", err);
  process.exit(1);
});

================
File: src/handlers/auth.handlers.ts
================
import { Request, Response } from "express";
import * as authService from "../services/auth.service.js";
import * as sessionUtils from "../utils/session.js";
import { AuthError, SessionError } from "../utils/errors.js";
import {
  registerSchema,
  loginSchema,
  passwordResetSchema,
  passwordResetRequestSchema,
} from "../utils/validate.js";

export async function handleRegister(req: Request, res: Response) {
  try {
    const validation = registerSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }

    const newUser = await authService.registerUser(validation.data);

    await sessionUtils.regenerateSession(req);
    sessionUtils.setUserSession(req, newUser.id, newUser.email);

    res.status(201).json(newUser);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handleLogin(req: Request, res: Response) {
  try {
    const validation = loginSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }

    const user = await authService.loginUser(validation.data);

    await sessionUtils.regenerateSession(req);
    sessionUtils.setUserSession(req, user.id, user.email);

    res.json(user);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handleLogout(req: Request, res: Response) {
  try {
    const sessionId = req.session.id;
    await sessionUtils.destroySession(req);

    res.clearCookie("sessionId");
    console.log(
      `Session ${sessionId} terminated at ${new Date().toISOString()}`,
    );

    res.json({ message: "Logged out successfully" });
  } catch (error) {
    handleError(error, res);
  }
}
export async function handlePasswordResetRequest(req: Request, res: Response) {
  try {
    const validation = passwordResetRequestSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }

    const result = await authService.requestPasswordReset(
      validation.data.email,
    );
    res.json(result);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handlePasswordReset(req: Request, res: Response) {
  try {
    const validation = passwordResetSchema.safeParse({
      token: req.params.token,
      ...req.body,
    });
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }

    const result = await authService.resetPassword(
      validation.data.token,
      validation.data.newPassword,
    );
    res.json(result);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handleGetSessions(req: Request, res: Response) {
  try {
    const sessions = await authService.getUserSessions(req.session.userId!);
    res.json(sessions);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handleTerminateSession(req: Request, res: Response) {
  try {
    const result = await authService.terminateSession(
      req.session.userId!,
      req.params.sessionId,
    );
    res.json(result);
  } catch (error) {
    handleError(error, res);
  }
}

export async function handleGetProfile(req: Request, res: Response) {
  try {
    const user = await authService.getUserById(req.session.userId!);
    res.json(user);
  } catch (error) {
    handleError(error, res);
  }
}

function handleError(error: unknown, res: Response) {
  console.error("Auth error:", error);

  if (error instanceof AuthError) {
    return res.status(401).json({ error: error.message });
  }

  if (error instanceof SessionError) {
    return res.status(400).json({ error: error.message });
  }

  res.status(500).json({ error: "Internal server error" });
}

================
File: src/middleware/auth.ts
================
import { Request, Response, NextFunction } from "express";
import { SessionExpiredError } from "../utils/errors.js";

export const isAuthenticated = (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // Check session expiry using timestamp
  const now = Date.now();
  if (!req.session.expiresAt || now > req.session.expiresAt) {
    req.session.destroy((err) => {
      if (err) {
        console.error("Session destruction error:", err);
      }
    });
    throw new SessionExpiredError("Session has expired");
  }

  // Extend session if it's close to expiring (within 15 minutes)
  const fifteenMinutes = 15 * 60 * 1000;
  if (req.session.expiresAt - now < fifteenMinutes) {
    req.session.expiresAt = now + 24 * 60 * 60 * 1000; // Extend by 24 hours
  }

  next();
};

================
File: src/middleware/rte-limiter.ts
================
import rateLimit from "express-rate-limit";

export const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: "Too many requests from this IP, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
});

export const loginRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 failed attempts
  skipSuccessfulRequests: true,
  message: "Too many failed login attempts, please try again later",
});

================
File: src/routes/auth.ts
================
import express from "express";
import * as authHandlers from "../handlers/auth.handlers.js";
import { isAuthenticated } from "../middleware/auth.js";
import { rateLimiter } from "../middleware/rte-limiter.js";

const router = express.Router();

router.post("/register", authHandlers.handleRegister);
router.post("/login", authHandlers.handleLogin);
router.post("/logout", isAuthenticated, authHandlers.handleLogout);
router.get("/me", isAuthenticated, authHandlers.handleGetProfile);

router.post(
  "/password-reset",
  rateLimiter,
  authHandlers.handlePasswordResetRequest,
);
router.post(
  "/password-reset/:token",
  rateLimiter,
  authHandlers.handlePasswordReset,
);
router.get("/sessions", isAuthenticated, authHandlers.handleGetSessions);
router.delete(
  "/sessions/:sessionId",
  isAuthenticated,
  authHandlers.handleTerminateSession,
);

export default router;

================
File: src/services/auth.service.ts
================
import bcrypt from "bcryptjs";
import crypto from "crypto";
import { db } from "../db/index.js";
import {
  loginAttempts,
  passwordResets,
  sessions,
  users,
} from "../db/schema.js";
import { and, eq, sql } from "drizzle-orm";
import { AuthError } from "../utils/errors.js";
import { sendPasswordResetEmail } from "../utils/email.js";

interface UserRegisterData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

interface UserLoginData {
  email: string;
  password: string;
}

export async function registerUser(userData: UserRegisterData) {
  const existingUser = await db
    .select()
    .from(users)
    .where(eq(users.email, userData.email));

  if (existingUser.length > 0) {
    throw new AuthError("Email already registered");
  }

  const hashedPassword = await bcrypt.hash(userData.password, 10);

  const [newUser] = await db
    .insert(users)
    .values({
      firstName: userData.firstName,
      lastName: userData.lastName,
      email: userData.email,
      password: hashedPassword,
    })
    .returning({
      id: users.id,
      email: users.email,
      firstName: users.firstName,
      lastName: users.lastName,
    });

  return newUser;
}

export async function loginUser(credentials: UserLoginData) {
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.email, credentials.email));

  if (!user) {
    throw new AuthError("Invalid credentials");
  }

  const validPassword = await bcrypt.compare(
    credentials.password,
    user.password,
  );
  if (!validPassword) {
    throw new AuthError("Invalid credentials");
  }

  return {
    id: user.id,
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
  };
}

export async function getUserById(userId: number) {
  const [user] = await db
    .select({
      id: users.id,
      email: users.email,
      firstName: users.firstName,
      lastName: users.lastName,
    })
    .from(users)
    .where(eq(users.id, userId));

  if (!user) {
    throw new AuthError("User not found");
  }

  return user;
}

export async function requestPasswordReset(email: string) {
  const [user] = await db.select().from(users).where(eq(users.email, email));

  if (!user) {
    // Return success even if user doesn't exist to prevent email enumeration
    return {
      message:
        "If your email exists in our system, you will receive a password reset link",
    };
  }

  const token = crypto.randomBytes(32).toString("hex");
  const expires = new Date();
  expires.setHours(expires.getHours() + 1); // Token valid for 1 hour

  // First, invalidate any existing reset tokens for this user
  await db
    .update(passwordResets)
    .set({ used: true })
    .where(eq(passwordResets.userId, user.id));

  // Then create a new reset token
  await db.insert(passwordResets).values({
    userId: user.id,
    token: await bcrypt.hash(token, 10),
    expiresAt: expires,
  });

  await sendPasswordResetEmail(user.email, token);

  return {
    message:
      "If your email exists in our system, you will receive a password reset link",
  };
}

export async function resetPassword(token: string, newPassword: string) {
  const [resetRequest] = await db
    .select()
    .from(passwordResets)
    .where(
      and(
        sql`${passwordResets.expiresAt} > NOW()`,
        eq(passwordResets.used, false),
      ),
    );

  if (!resetRequest) {
    throw new AuthError("Invalid or expired reset token");
  }

  const tokenValid = await bcrypt.compare(token, resetRequest.token);
  if (!tokenValid) {
    throw new AuthError("Invalid or expired reset token");
  }

  const hashedPassword = await bcrypt.hash(newPassword, 10);

  await db.transaction(async (tx) => {
    await tx
      .update(users)
      .set({ password: hashedPassword })
      .where(eq(users.id, resetRequest.userId));

    await tx
      .update(passwordResets)
      .set({ used: true })
      .where(eq(passwordResets.id, resetRequest.id));

    // Invalidate all sessions for this user
    await tx.delete(sessions).where(eq(sessions.userId, resetRequest.userId));
  });

  return { message: "Password reset successful" };
}

export async function getUserSessions(userId: number) {
  const activeSessions = await db
    .select({
      id: sessions.sid,
      userAgent: sessions.userAgent,
      ipAddress: sessions.ipAddress,
      lastActivity: sessions.lastActivity,
      createdAt: sessions.createdAt,
    })
    .from(sessions)
    .where(and(eq(sessions.userId, userId), sql`${sessions.expire} > NOW()`));

  return activeSessions;
}

export async function terminateSession(userId: number, sessionId: string) {
  const result = await db
    .delete(sessions)
    .where(and(eq(sessions.sid, sessionId), eq(sessions.userId, userId)))
    .returning();

  if (!result.length) {
    throw new AuthError("Session not found");
  }

  return { message: "Session terminated successfully" };
}

export async function recordLoginAttempt(
  email: string,
  success: boolean,
  ipAddress: string,
) {
  await db.insert(loginAttempts).values({
    email,
    success,
    ipAddress,
    timestamp: new Date(),
  });

  if (!success) {
    const recentFailures = await db
      .select({ count: sql<number>`count(*)` })
      .from(loginAttempts)
      .where(
        and(
          eq(loginAttempts.email, email),
          eq(loginAttempts.success, false),
          sql`${loginAttempts.timestamp} > NOW() - INTERVAL '15 minutes'`,
        ),
      );

    if (recentFailures[0].count >= 5) {
      throw new AuthError("Too many failed attempts. Please try again later.");
    }
  }
}

================
File: src/types/session.d.ts
================
import "express-session";

declare module "express-session" {
  interface SessionData {
    userId: number;
    email: string;
    expiresAt: number;
  }
}

================
File: src/utils/email.ts
================
import nodemailer from "nodemailer";

const transporter = nodemailer.createTransport({
  // Configure your email service
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  secure: process.env.SMTP_SECURE === "true",
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export async function sendPasswordResetEmail(email: string, token: string) {
  const resetLink = `${process.env.APP_URL}/reset-password/${token}`;

  await transporter.sendMail({
    from: process.env.SMTP_FROM,
    to: email,
    subject: "Password Reset Request",
    html: `
      <h1>Password Reset Request</h1>
      <p>Click the link below to reset your password. This link will expire in 1 hour.</p>
      <a href="${resetLink}">Reset Password</a>
      <p>If you didn't request this, please ignore this email.</p>
    `,
  });
}

================
File: src/utils/errors.ts
================
export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public code?: string,
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

// Error handler middleware
import { Request, Response, NextFunction } from "express";

export const errorHandler = (
  err: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      status: "error",
      code: err.code,
      message: err.message,
    });
  }

  console.error("Unhandled error:", err);
  return res.status(500).json({
    status: "error",
    message: "Internal server error",
  });
};

export class SessionExpiredError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "SessionExpiredError";
  }
}

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthError";
  }
}

export class SessionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "SessionError";
  }
}

================
File: src/utils/session.ts
================
import { Request } from "express";
import { SessionError } from "./errors.js";
import { db } from "../db/index.js";
import { sessions } from "../db/schema.js";
import { eq } from "drizzle-orm";

export async function regenerateSession(req: Request): Promise<void> {
  return new Promise((resolve, reject) => {
    req.session.regenerate((err) => {
      if (err) reject(new SessionError("Failed to regenerate session"));
      resolve();
    });
  });
}

export async function destroySession(req: Request): Promise<void> {
  return new Promise((resolve, reject) => {
    req.session.destroy((err) => {
      if (err) reject(new SessionError("Failed to destroy session"));
      resolve();
    });
  });
}

export async function setUserSession(
  req: Request,
  userId: number,
  email: string,
) {
  req.session.userId = userId;
  req.session.email = email;
  req.session.expiresAt = Date.now() + 24 * 60 * 60 * 1000;

  // Update session record with additional tracking information
  await db
    .update(sessions)
    .set({
      userId: userId,
      userAgent: req.get("user-agent") || null,
      ipAddress: req.ip || req.socket.remoteAddress || null,
      lastActivity: new Date(),
    })
    .where(eq(sessions.sid, req.session.id));
}

export async function updateSessionActivity(req: Request) {
  if (req.session.id) {
    await db
      .update(sessions)
      .set({
        lastActivity: new Date(),
      })
      .where(eq(sessions.sid, req.session.id));
  }
}

================
File: src/utils/validate.ts
================
import { z } from "zod";

export const passwordSchema = z
  .string()
  .min(8)
  .max(100)
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(
    /[^A-Za-z0-9]/,
    "Password must contain at least one special character",
  );

export const registerSchema = z
  .object({
    firstName: z
      .string()
      .min(2, "First name must be at least 2 characters")
      .max(50, "First name must not exceed 50 characters")
      .regex(/^[A-Za-z\s-']+$/, "First name contains invalid characters"),
    lastName: z
      .string()
      .min(2, "Last name must be at least 2 characters")
      .max(50, "Last name must not exceed 50 characters")
      .regex(/^[A-Za-z\s-']+$/, "Last name contains invalid characters"),
    email: z.string().email("Invalid email format").toLowerCase().trim(),
    password: passwordSchema,
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

export const loginSchema = z.object({
  email: z.string().email("Invalid email format").toLowerCase().trim(),
  password: z.string().min(1, "Password is required"),
});
export const passwordResetRequestSchema = z.object({
  email: z.string().email("Invalid email format").toLowerCase().trim(),
});

export const passwordResetSchema = z
  .object({
    token: z.string().min(1, "Reset token is required"),
    newPassword: passwordSchema,
    confirmPassword: z.string(),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

export type RegisterInput = z.infer<typeof registerSchema>;
export type LoginInput = z.infer<typeof loginSchema>;

================
File: src/index.ts
================
import express from "express";
import session from "express-session";
import pgSession from "connect-pg-simple";
import { db } from "./db/index.js";
import { users } from "./db/schema.js";
import cors from "cors";
import authRouter from "./routes/auth.js";
import { isAuthenticated } from "./middleware/auth.js";
import { SessionExpiredError } from "./utils/errors.js";

const app = express();
const port = process.env.PORT || 3000;
app.use(cors());
// Middleware
app.use(express.json());

if (!process.env.SESSION_SECRET) {
  console.error("SESSION_SECRET is required but was not provided");
  process.exit(1);
}
// Session configuration
const PostgresqlStore = pgSession(session);
const sessionStore = new PostgresqlStore({
  conObject: {
    connectionString: process.env.DATABASE_URL,
  },
  tableName: "session",
  createTableIfMissing: true,
  pruneSessionInterval: 60 * 15, // Prune expired sessions every 15 minutes
});

app.use(
  session({
    store: sessionStore,
    secret: process.env.SESSION_SECRET || "your-secret-key",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
      sameSite: "strict",
    },
    rolling: true, // Reset maxAge on every response
    name: "sessionId", // Custom cookie name
  }),
);

// Global error handler
app.use(
  (
    err: Error,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction,
  ) => {
    if (err instanceof SessionExpiredError) {
      return res.status(440).json({ error: "Session has expired" });
    }

    console.error(err);
    res.status(500).json({ error: "Internal server error" });
  },
);

// Routes
app.use("/api/auth", authRouter);

// Protected route example
app.get("/api/users", async (req, res) => {
  try {
    const allUsers = await db
      .select({
        id: users.id,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
      })
      .from(users);
    res.json(allUsers);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});

================
File: drizzle.config.ts
================
import type { Config } from "drizzle-kit";
import * as dotenv from "dotenv";

dotenv.config();

export default {
  schema: "./src/db/schema.ts",
  out: "./drizzle",
  driver: "pg",
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  // Add verbose logging
  verbose: true,
  // Add strict mode for better error reporting
  strict: true,
} satisfies Config;

================
File: package.json
================
{
  "name": "node-drizzle-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "generate": "drizzle-kit generate:pg",
    "migrate": "tsx src/db/migrate-db.ts",
    "migrate2": "drizzle-kit push:pg",
    "studio": "drizzle-kit studio",
    "seed": "tsx src/db/seed.ts",
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
    "test:watch": "node --experimental-vm-modules node_modules/jest/bin/jest.js --watch",
    "test:coverage": "node --experimental-vm-modules node_modules/jest/bin/jest.js --coverage"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "connect-pg-simple": "^10.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "drizzle-orm": "^0.29.3",
    "express": "^4.18.2",
    "express-rate-limit": "^7.4.1",
    "express-session": "^1.18.1",
    "nodemailer": "^6.9.16",
    "postgres": "^3.4.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "^20.17.6",
    "@types/nodemailer": "^6.4.16",
    "drizzle-kit": "^0.20.14",
    "tsx": "^4.7.0",
    "typescript": "^5.6.3"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["src/**/*", "drizzle.config.ts"],
  "exclude": ["node_modules"]
}
